## 风格

### 排序

#### 模块内自上而下的排序

在一个模块内，我们更倾向于自上而下的排序。这意味着模块内的项目将依赖于它们下面定义的项目，但通常不会依赖于它们上面的项目。这样做的理念是，公共API，具有更多内部依赖，将被更频繁地读取（和更改），并且将其放在模块的顶部使其更易于访问。

这可能会让许多习惯于像Python这样的语言中自下而上排序的工程师感到惊讶，其中项目可以在运行时依赖于在同一模块中定义的其他项目。

通常，`const`值将放在模块的底部（最不复杂，通常没有自己的依赖关系），尽管在较大的模块中，将`const`直接放在用户下面可能更有意义（特别是如果只有一个用户，或者只有几个位于同一位置的用户）。

#### 给定类型的排序

对于给定的类型，我们更倾向于按以下顺序排序项目：

1. 类型定义
2. 类型的方法实现
3. 对于特定接口的实现，从最具体到最不具体。
   最不具体的可能是像`Stringer`的实现。

#### 排序方法

0. 构造函数，从接受最少参数的构造函数开始
1. 值接收者的公共API
2. 指针接收者的公共API
3. 值接受者的私有API
4. 指针接收者的私有API
5. `const`值

### 函数

#### 考虑避免短的单一用途函数

虽然单一用途函数在算法足够复杂以至于需要一个明确的名称和接口时是有意义的，但使用许多短的单一用途函数可能会使代码更难以跟踪，因为需要在不同的地方跳转以理解正在发生什么。当编写一个单一用途函数时，考虑是否需要专用的接口，或者是否可以将其内联到其调用者中。

#### 考虑避免自由函数

如果一个函数的语义或实现强烈依赖于其参数之一，并且该参数在当前包中定义了一个类型，那么我们更倾向于在该类型上使用一个方法。同样，如果一个函数接受多个来自同一公共类型的参数，在所有调用站点都是成为该类型方法的强烈候选者。

#### 从最具体到最不具体的顺序排列参数

当编写一个函数时，我们倾向于从最具体到最不具体的顺序排列参数。这意味着`image_id`可能会在`domain`之前，`domain`会在`app`上下文之前。更具体的参数在区分给定函数和其他函数之间有更大的差异，所以将它们放在前面使得更容易推断函数的上下文/含义（与开始时有许多通用上下文类型相比）。

#### 验证

在可能的情况下，避免编写基于已填充对象状态检查错误条件的`validate`或`check`类型函数。更倾向于使用["解析而非验证"](https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/)的风格，并尽量利用类型系统使无效状态无法表示。

#### 错误处理

除了单元测试和集成测试之外，我们倾向于避免忽略错误，比如使用`_`，错误应该被显式处理，除非有明确的不变性可以通过代码结构进行本地验证。如果存在这样的不变性，我们通常会添加一条注释来解释如何维护不变性。在其他情况下（特别是可能由网络流量引起的错误情况，可能代表攻击者），我们始终优先处理错误，并最终向网络对等方返回错误或关闭连接。

### 表达式

#### 避免单独使用的绑定

如果可能的话，我们通常会避免变量绑定，如果一个变量只使用一次。给变量命名需要费神，跟踪绑定的引用也需要费神。我们喜欢将给定作用域中的可变绑定数量最小化。

请记住，总体目标是使代码易于理解。。

#### 提前使用`return`和`continue`来减少嵌套

Go的特性可能导致某些代码出现深度缩进，我们称之为"右向漂移"。这使得代码行变短，使代码更难阅读。为了避免这种情况，尝试在错误情况下提前使用`return`，或者在循环中提前使用`continue`来跳过迭代。

### 命名

#### 使用简洁的名称

我们更倾向于使用简洁的名称，特别是对于局部变量，但是对于不太常见的缩写或缩写，我们更倾向于展开（例如，更倾向于使用 `key_usage` 而不是 `ku`，`anonymous` 而不是 `anon`）。极其常见的缩写形式，如 `url`，是可以接受的。

避免为描述变量类型的变量添加后缀（前提是它的类型很难与其他类型混淆 - 例如，我们仍然使用 `_id` 后缀，因为我们通常使用数字 ID 来表示数据库实体）。变量名称的精确性/简洁性权衡也取决于绑定的作用域。

#### 避免使用 `get` 前缀

不推荐使用 `get()` 前缀。

#### 枚举变体

Go本身不具有枚举类型，但是可以通过 `const` 块实现枚举的效果，在需要在实现或修改枚举类型时，按字母顺序列出其变体。当需要遵循外部来源（例如标准文档）的顺序时，可以忽略此建议。

变体名称应使用主动动词。例如，使用 `Allow` 而不是 `Allowed`，使用 `Forbid` 而不是 `Forbidden`。避免使用 `Yes` 和 `No` 这样的伪布尔值，而是使用描述不同状态的变体名称。

### 导入

我们在 Go 文件中使用了三个导入块：

1. `std` 导入
2. 来自外部库的导入
3. 内部库的导入

我们认为这样做可以更容易地看出特定导入来自哪里。

当符号名称过于通用或容易在不同的库之间混淆时。在这种情况下，我们更喜欢将符号名称导入为别名。例如，使用 `swaggerFiles "github.com/swaggo/files"`。

### 导出

只导出必要的类型，使对模块外暴露的接口尽可能少。

### 其他

#### 数字字面量

优先选择与所使用值的领域相符的数字进制。例如，对于协议消息字面量，使用十六进制；对于 UNIX 权限，使用八进制。使用数字分组使较大的数字常量易于阅读，例如使用 `100_000_000` 而不是 `100000000`。